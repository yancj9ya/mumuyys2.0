# this file is used to manage the tasks in the PIGEON system.
from time import sleep
from threading import Thread, Event
from datetime import datetime, timedelta
import json
from task import Xz, Tp, Dg, Ltp, Ql, Hd, Ts, Yh, Ad, Jy
from task.based.switchui.SwitchUI import SwitchUI
from task.based.soulchange.soulchange import SoulChange
from PIGEON.log import log
from PIGEON.MidTrans import Task


class TaskManager:
    F_MAP = {"结界寄养": Jy, "结界突破": Tp, "地域鬼王": Ad, "寮突破": Ltp, "契灵": Ql, "智能": Hd, "绘卷": Ts, "御魂": Yh, "道馆": Dg}
    STOPSIGNAL = Event()
    scheduler_event = Event()

    def __init__(self):

        self.tasks_ready = []
        self.tasks_waiting = []
        self.tasks_completed = []
        self.running_task = None
        self.running_state = False
        self.switch_ui = SwitchUI(running=self.STOPSIGNAL)
        self.soul_change = SoulChange(running=self.STOPSIGNAL)

    def Gui_to_manager(self, **kwargs):
        if kwargs["action"] == "add":
            # log.info(f"Adding {kwargs['add_task'].name} to the task manager.")
            self.decide_pool(kwargs["add_task"])
        elif kwargs["action"] == "remove":
            # log.info(f"Removing {kwargs['del_task'].name} from the task manager.")
            if self.running_task == kwargs["del_task"]:
                self.running_task = None
                pass
            elif kwargs["del_task"] in self.tasks_ready:
                self.tasks_ready.remove(kwargs["del_task"])
            elif kwargs["del_task"] in self.tasks_waiting:
                self.tasks_waiting.remove(kwargs["del_task"])

    def decide_pool(self, task):
        task_config = self.load_task_config()[task.name]
        start_time, end_time = task_config["run_time"].split("-")
        start_time = datetime.strptime(start_time, "%H:%M")
        end_time = datetime.strptime(end_time, "%H:%M")
        if end_time < start_time:
            if datetime.now().time() < end_time.time() or datetime.now().time() > start_time.time():
                if task not in self.tasks_ready:
                    if task.name == "结界寄养":
                        self.tasks_ready.insert(0, task)
                    else:
                        self.tasks_ready.append(task)
                    task.set_state("ready")
                    log.info(f"{task.name} is ready to run.")
                    return

        if datetime.now().time() < start_time.time() or datetime.now().time() > end_time.time():
            if task not in self.tasks_waiting:
                self.tasks_waiting.append(task)
                task.set_state("waiting")
                task.task_state.configure(fg_color="lightyellow")
                log.info(f"{task.name} is waiting for start .")
        else:
            if task not in self.tasks_ready:
                self.tasks_ready.append(task)
                task.set_state("ready")
                log.info(f"{task.name} is ready to run.")

    def choose_task(self):
        if len(self.tasks_ready) > 0:
            self.running_task = self.tasks_ready.pop(0)

    def loop_ask(self, **kw):
        # 日志初始化
        log.insert("1.0", f"{'━'*14}统计{'━'*14}\n\n\n\n\n{'━'*14}日志{'━'*14}\n", tags="sep")
        # 匹配模式循环检测任务状态
        while kw["STOPSIGNAL"].is_set():
            match [self.running_task, self.running_state]:
                case [None, False]:
                    self.choose_task()  # 前一任务执行完成或刚开始，选择执行任务
                    for task in self.tasks_waiting:  # 每隔一秒检查一下等待任务池是否有任务位于可执行时间
                        self.decide_pool(task)
                case [object(), False]:
                    if Task.TASK_PROCESS == "STOP":
                        Thread(target=self._task, kwargs={"parms": self.load_task_config()[self.running_task.name]}).start()
                        self.running_task.set_state("running")
                        self.running_state = True  # 有任务执行
                        self.STOPSIGNAL.set()
                    elif Task.TASK_PROCESS == "RUNNING":
                        pass
            sleep(0.5)

    def _task_done(self):
        self.running_task.set_state("done")
        self.running_task.task_state.configure(fg_color="lightgray")
        self.running_task = None
        self.running_state = False  # 任务执行完成，状态置为False
        self.tasks_completed.append(self.running_task)

    def _task_need_change_soul(self, parms=None, **kwargs):
        if parms["change_soul"] != "false":
            self.soul_change.changeSoulTo(parms["change_soul"])  # 更换御魂
            pass

    def _creat_task_instance(self, parms=None, **kwargs):
        log.info(f"Start {parms["task_id"]} task.")
        task_instance = self.F_MAP.get(parms["task_id"])(STOPSIGNAL=self.STOPSIGNAL, **kwargs)
        task_instance.set_parms(**parms)
        task_instance.loop()
        if hasattr(task_instance, "next_time"):
            return task_instance.next_time

    def _task(self, parms=None, **kwargs):
        log.info(f"parms: {parms}, kwargs: {kwargs}")
        try:
            self._task_need_change_soul(parms=parms, **kwargs)
            while not self.switch_ui.switch_to(parms["start_ui"]):
                continue  # 切换到开始界面
            instance_return = self._creat_task_instance(parms=parms, **kwargs)
            # 任务结束后，根据配置是否重复执行任务
            if parms.get("repeat", False):
                time_delta = timedelta(hours=int(instance_return.split(":")[0]), minutes=int(instance_return.split(":")[1]) + 1)
                task_config = self.load_task_config()
                if "run_time" in task_config[self.running_task.name]:
                    task_config[self.running_task.name]["run_time"] = (datetime.now() + time_delta).strftime("%H:%M") + "-" + (datetime.now() + time_delta + timedelta(hours=6)).strftime("%H:%M")
                    self.write_task_config(task_config)
                self.running_task.task_master().add_task(self.running_task.name)

                pass
        except Exception as e:
            log.info(f"_task function Error in {parms["task_id"]} task: {e}")

        finally:
            self._task_done()
            while not self.switch_ui.switch_to("home_page_unfold"):
                continue  # 切换到结束界面
        pass

    def write_task_config(self, task_config):
        with open("GUI/task_option.json", "w") as f:
            json.dump(task_config, f)

    def load_task_config(self):
        with open("GUI/task_option.json", "r") as f:
            return json.load(f)

    def start_work(self, **kwargs):
        match kwargs["action"]:
            case "start":
                self.scheduler_event.set()
                self.STOPSIGNAL.set()
                Thread(target=self.loop_ask, kwargs={"STOPSIGNAL": self.scheduler_event}).start()
                Thread(target=Xz.start_deamon, kwargs={"STOPSIGNAL": self.scheduler_event}).start()  # 协助邀请 线程
                if kwargs["start_btn"] is not None:
                    kwargs["start_btn"].configure(fg_color="Red", text="正在运行")
            case "stop":
                self.scheduler_event.clear()
                self.STOPSIGNAL.clear()
                self.running_state = False
                if kwargs["start_btn"] is not None:
                    kwargs["start_btn"].configure(fg_color="Green", text="开始运行")


taskManager = TaskManager()
